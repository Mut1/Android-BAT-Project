#### 优质文章：

https://www.cnblogs.com/qianguyihao/p/4748392.html

https://qwerhuan.gitee.io/2020/10/22/java/jvm-ji-chu-er-yun-xing-shi-shu-ju-qu/

<img src="https://s1.ax1x.com/2020/10/21/BPZ6OI.png" alt="BPZ6OI" style="zoom:60%;" />

#### java中的内存分配：

java程序在运行时，需要在内存中的分配空间。

为了提高运算效率，就对数据进行了不同空间的划分.

具体划分为如下5个内存空间：（非常重要）

- 栈：存放局部变量
- 堆：存放所有new出来的东西
- 方法区：被虚拟机加载的类信息、常量、静态变量等
- 程序计数器（和系统相关）
- 本地方法栈

##### 程序计数器

> 程序计数器是当前线程所执行的字节码的行号指示器，标记程序下一条代码运行位置。
>
> 程序计数器为线程私有。
>
> Java的多线程实现方式是线程轮换来分配处理器的执行时间。当线程被挂起时，程序计数器会记录当前线程代码的执行位置，当线程恢复时可以恢复到正确的代码执行位置。
>
> 执行本地方法,PC值为0
>
> 程序计数器中存储的数据所占空间的大小不会随程序的执行而发送改变，所以此区域不会出现OutOfMemoryError的情况

##### 方法区

> 方法区主要存放类信息、常量、静态变量、即时编译后的代码缓存，以及类、方法、字段的符号引用等。
>
> 方法区为线程共享。
>
> class文件中的类被加载后存放在方法区中。
>
> 常量，也就是final类型的变量且在编译阶段就能确定数值；以及静态变量均放在这个地方。
>
> 字节码被解释器解释后的机器码，也会缓存在这个区域中。
>
> 同时，未加载的类、方法调用位置等等，这些需要有一地址去调用。如类的加载，首先虚拟机要知道有这样一个类和这个类的位置，然后才能判断类是否存在和去哪里加载这个类，这个就是类的符号引用，其他类似。
>
> jdk8之后HotSpot就放弃了永生代，改用本地内存实现的元空间。
>
> 当无法满足新的内存分配需求的时候，会抛出OutMemoryError异常。

##### 运行时常量池

> 常量池属于方法区的一部分，主要存储数据常量以及符号引用。
>
> 常量，就是final修饰的常量
>
> 符号引用有：包名、类的全限定名称、方法名称描述符等等。
>
> 常量池并非只有在编译阶段才能创建数据，在运行阶段也可以在常量池中添加数据，如String的intern方法。所以当常量池无法拓展内存时，会抛出OutOfMemoryError异常。
>

堆区（Heap）

> 堆区主要存放对象实例，是垃圾回收的主要目标。
>
> 堆区在物理上可以不连续，但在逻辑上一定是连续的。
>
> 堆区为线程共享。
>
> 创建的一切对象以及数组（其实数组也是一种对象），都分配在堆区，同时Class对象（注意，这个class对象指的是类本身，而不是由类创建出来的对象）也是存储在堆区
>
> 堆区并不是一整块内存，而是会进行划分实现不同的特性，如分代设计、线程缓冲区等，用以解决**垃圾回收**、线程安全等问题
>
> 堆区大小可以是可拓展的，也可以是固定的。目前主流的虚拟机均设计为可拓展型。当堆申请内存失败，无法拓展时，会抛出OutOfMemoryError异常。
>
>
> 

##### 本地方法栈

> 与虚拟机栈非常类似，其区别不过是虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方法栈则是为**虚拟机使用到的Native方法服务。**
>
> 该区域可能抛出以下异常：
>
> 1. 当线程请求的栈深度超过最大值，会抛出 [StackOverflowError](https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fqq_30739519%2Farticle%2Fdetails%2F51042584) 异常；
> 2. 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

##### 虚拟机栈

> **线程私有，生命周期和线程相同**
>
> 栈由一系列帧组成（因此java栈也叫做栈帧）
>
> 栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。
>
> **每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。**
>
> 该区域可能抛出以下异常：
>
> 1. 当线程请求的栈深度超过最大值，会抛出 [StackOverflowError](https://link.juejin.cn/?target=https%3A%2F%2Fblog.csdn.net%2Fqq_30739519%2Farticle%2Fdetails%2F51042584) 异常；
> 2. 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。

4.1局部变量表：

存放编译期可知的各种基本数据类型、对象引用。

4.2函数调用组成栈帧：

4.3java栈之操作数栈

java没有寄存器，所有参数传递都是使用操作数栈

4.4java栈之栈上分配

>小对象（一般几十个bytes），在没有逃逸的情况下，可以直接分配在栈上
>
>直接分配在栈上，可以自动回收，减轻GC压力
>
>大对象或者逃逸对象无法栈上分配