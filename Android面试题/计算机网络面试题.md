#### 四次挥手为什么必须等待2MSL时间？

第一：为了保证A发送的最后一个ACK报文能够到达B。这个ACK报文段有可能丢失，因此使处在LAST-ACK状态的B收不到对自己发送的FIN+ACK报文段的确认。B会超时重传FIN+ACK报文段，而此时A就能在2MSL时间内收到这个重传的FIN+ACK报文段。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常的步骤进入CLOSED状态。

第二：A在发送完ACK报文段后，再经过2MSL时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现旧的连接请求的报文段。

#### HTTP常见状态码

301是永久重定向，而302是临时重定向

#### TCP和UDP的特点和区别？

##### 用户数据报协议UDP

是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部），支持一对一、一对多、多对一和多对多的交互通信。

##### 传输控制协议TCP

是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条TCP连接只能是点对点的（一对一）

#### TCP粘包、拆包及解决方案

##### 为什么会发生 TCP 粘包、拆包？

- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
- 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

##### 粘包、拆包解决办法

消息定长：发送端将每个数据包封装为固定长度

设置消息边界：服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割

将消息分为消息头和消息体

#### TCP 拥塞控制

TCP主要通过四个算法来进行拥塞控制：

慢开始、拥塞避免、快重传、快恢复

#### 说一下一次完整的HTTP请求过程包括哪些内容？

域名解析 --> 

发起TCP的3次握手 -->

 建立TCP连接后发起http请求 -->

 服务器响应http请求，浏览器得到 html代码 --> 

浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 

浏览器对页面进行渲染呈现给用户。

#### DNS的工作原理？

将主机域名转换为ip地址，属于应用层协议，使用UDP传输。

##### 为什么域名解析用UDP协议？

因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。

而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是UDP协议传输内容不能超过512字节。不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。

#### HTTP长连接和短连接的区别

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

从HTTP/1.1起，默认使用长连接，用以保证连接特性。

#### 什么是TCP粘包/拆包？发生的原因？

一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。

##### 原因：

1. 应用程序写入数据的字节大小大于套接字发送缓冲区的大小
2. 进行MSS大小的TCP分段
3. 以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）

##### 解决方案

1. 消息定长
2. 在包尾部增加回车或者空格符等特殊字符进行分割
3. 将消息分为消息头和消息尾
4. 使用其它复杂的协议，如RTMP协议

#### HTTP请求方法你知道多少？

#### GET 和 POST 的区别，你知道哪些？

1. get是获取数据，post是修改数据

2. get把请求的数据放在url上，以？分割url和传输数据，参数之间以&相连，所以get不太**安全**。

   而post把数据放在HTTP的包体内（request body）

3. get提交的数据最大是2k（实际取决浏览器），post理论上没有限制（但取决于服务器限制）

4. get产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

   post产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）（chrome不会分开发送，不是post的必然行为）

5. GET请求会被浏览器主动缓存，而POST不会，除非手动设置

6. 本质区别：GET是幂等的，而POST不是幂等的

#### 一个TCP连接可以对应几个HTTP请求？

如果维持连接，一个TCP连接是可以发送多个HTTP请求的

#### 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个 请求，再三个响应一起接收）？

在HTTP/1.1存在一个问题，单个TCP连接在同一时刻只能处理一个请求，意义是说：两个请求的生命周期不能重叠，任意两个HTTP请求从开始到结束的时间在同一个TCP连接里不能重叠。

在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。

在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连 接中并行进行。

那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：

- 维持和服务器已经建立的TCP连接，在同一连接上顺序处理多个请求。
- 和服务器建立多个TCP连接。

#### 在浏览器中输入url地址后显示主页的过程?

- 根据域名，进行DNS域名解析
- 拿到解析的IP地址，建立TCP连接
- 向IP地址，发送HTTP请求
- 服务器处理请求，并返回响应结果
- 关闭TCP连接
- 浏览器解析HTML
- 浏览器布局渲染

#### 在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？

1. 查浏览器缓存，看看有没有已经缓存好的，如果没有
2. 检查本机host文件
3. 调用API，Linux下Scoket函数 gethostbyname
4. 向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议
5. 如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行 DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球好像一共有13台根服 务器）
6. 这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会首先尝试http然后调用Socket建立TCP连接，
7. 经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了
8. 如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，
9. 再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安 全性，保证数据传输过程中不被修改或者替换之类的
10. 这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的 CA安全证书。
11. 确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面 进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页

#### HTTPS和HTTP的区别

#### 什么是SSL/TLS ？

#### HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）

#### 如何保证公钥不被篡改？

#### HTTP请求和响应报文有哪些主要字段？

#### Cookie是什么？

Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发送时被携带上，用于告知服务端两个请求是否来自同一个浏览器。

抽象地概括一下：

一个 cookie 可以认为是一个「变量」， 形如 name=value， 存储在浏览器；

一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。

#### Cookie有什么用途？用途

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

#### Session知识大总结

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服 务器端的信息更加安全。

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数 据库中，效率会更高。

#### Session 的工作原理是什么？

过程如下：

- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
- 服务器验证该用户名和密码， 如果正确则把用户信息存储到 Redis 中， 它在 Redis 中的 Key 称为 Session ID； 
- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 
- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操 作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用 短信验证码等方式。

#### Cookie与Session的对比，如何选择？

##### Cookie

cookie是客户端保持状态的方法。

##### Session

Session是服务器保持状态的方法

#### 网络的七层模型与各自的功能（图片版）

![](https://mut-pic-1305269047.cos.ap-nanjing.myqcloud.com/20210820172749.png)

#### POST 方法比 GET 方法安全？

有人说POST 比 GET 安全，因为数据在地址栏上不可见。

然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。

要想安全传输，就只有加密，也就是 HTTPS。

#### DDos 攻击了解吗？

客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。

没有彻底根治的方法，除非不使用TCP

DDos预防：

1. 限制同时打开SYN半链接的数目
2. 缩点SYN半链接的Time out时间
3. 关闭不必要服务

#### MTU和MSS分别是什么？

MTU是最大传输单元，由硬件规定，如以太网的MTU为1500字节

MSS：最大分节大小，为TCP数据包每次传输的最大数据分段大小。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。

#### 对称密钥加密的优点缺点？

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

优点：运算速度快

缺点：无法安全地将密钥传输给通信方

#### 非对称密钥加密你了解吗？优缺点？

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。

公开密钥所有人都可以获得，**通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密， 接收方收到通信内容后使用私有密钥解密。**

非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使 用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

优点：可以更安全地将公开密钥传输给通信发送方

缺点：运算速度慢

#### 为什么有的时候刷新页面不需要重新建立 SSL 连接？

TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP 不需要重新建立，SSL 自然也会用之前的。

#### HTTP如何禁用缓存？如何确认缓存？

HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

禁止进行缓存

no-store 指令规定不能对请求或响应的任何一部分进行缓存。

Cache-Control: no-store

强制确认缓存

no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使 用该缓存对客户端的请求进行响应。

Cache-Control: no-cache

#### 网络层常见协议？可以说一下吗？

#### TCP四大拥塞控制算法总结？（极其重要）

四大算法

拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一 天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。

#### 你了解流量控制原理吗？

- 目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致 接收方不能接收的问题。所以流量控制是点对点控制。
- TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。
  - 发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中 窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。
  - 接收窗：用来标记可以接收的数据大小。

#### TCP 协议如何保证可靠传输？

- 确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。 
- 数据校验：TCP报文头有校验和，用于校验报文是否损坏。 
- 数据合理分片和排序：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于 UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。 
- 流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- 拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

#### 数据链路层常见协议？可以说一下吗？

ARP：地址解析协议 根据IP地址获取物理地址

RARP：反向地址转换协议  根据物理地址获取IP地址

#### Ping命令基于哪一层协议的原理是什么？

ping命令基于网络层的命令，是基于ICMP协议工作的。

ICMP协议：Internet控制报文协议
