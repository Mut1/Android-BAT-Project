![image-20210826184239631](../../../Library/Application%20Support/typora-user-images/image-20210826184239631.png)

#### 阿里一面

代码题

写一个获取线程唯一id的方法，不允许使用线程自身id，

问答题

介绍项目  项目框架  项目设计模式

okhttp设计原理

glide设计原理

recylerview设计原理

自定义的流程，onMeasure几个参数

事件分发（问的不难，简单的说一下传递过程，几个关键方法就结束这个话题了）

操作系统  

arrayList  linkedlist区别，arrayList除了数组还用什么数据结构

sychronized和violatile

虚拟机栈（一直问，局部变量表、方法出口什么的都讲了，不知道讲了什么。但感觉面试官好像还不是想要这个回答。。）

编译原理

字节码编译的什么LR方法（我真的听都没过）

GC root有哪些

handler  message持有activity引用，导致内存泄漏，到底谁持有？

handler原理

主线程looper循环为什么不造成卡死？（这个最气，我觉得我回答的对的）

软引用

怎么排查内存泄漏

LruCache ----》说到源码里具体哪个方法实现了最近最少使用。说了put get流程都不行。。。！！！！

。。。还有想不起来了



作者：我心永恒1221
链接：https://www.nowcoder.com/discuss/710315?channel=-1&source_id=discuss_terminal_discuss_history_nctrack&ncTraceId=4ff427714beb45db911ccfcbb0009b39.395.16293019931923997
来源：牛客网



一面 8.15 15:00： 

  1、自我介绍。 

  2、Android相关。 

  3、设计模式相关（本人只会单例模式）。 

  4、计算机网络相关（问的最多，包括三握四挥、HTTPS等）。 

  5、代码：判断[链表]()是否有环。 

  6、反问。 

  


  二面 8.15 16:00： 

  1、自我介绍。 

  2、Android相关。 

  3、多线程相关。 

  4、Java集合相关。 

  5、OOM异常相关。 

  6、JVM内存模型和类加载机制。 

  7、[红黑树]()。 

  8、网络流量控制。 

  9、代码：删除[链表]()的第n个结点。 

  10、反问。 

  


  hr面 8.15 18:10： 

  1、个人相关（籍贯等）。 

  2、个人的性格缺点。 

  3、工作期望地点。 

  4、三年规划。 

  5、[项目]()中遇到的最大困难以及如何解决的。 

  6、考虑公司的因素。 

  7、周围同学的去向。 

  8、其他公司的面试进度以及倾向性。 

  9、反问。 



------------------------------------------------------------------------------------------------

作者：摸不着头发
链接：https://www.nowcoder.com/discuss/707976?channel=-1&source_id=discuss_terminal_discuss_history_nctrack&ncTraceId=4ff427714beb45db911ccfcbb0009b39.264.16293020316007179
来源：牛客网



### 一面： 

1.  Java的集合体系，LinkedList和ArrayList的区别？ 
2.  HashMap的原理，解决哈希冲突的方法？有没有用过LinkedMap?HashSet的原理? 
3.  Activity的生命周期，OnPause方法调用后是否立即调用OnStop？（不是立即调用，要等新的Activity调用OnResume方法以后） 
4.  JVM内存模型，垃圾回收[算法]()？ 
5.  是否用过onSaveInstanceState？怎么在Activity销毁之前保存数据? 
6.  MVVM和MVP的异同点？ 
7.  DataBingding的底层原理？ 

 Retorfit的底层原理？Handler的底层原理? 

1.  Handler中的postDelay方法，具体到底层中是怎样的实现流程？ 
2.  自定义View流程，OnMeausre方法具体需要做哪些事情？ 
3.  [算法]()：手写一个[链表]()。问：如何移除倒数第二个节点（增加前序指针） 

   反问：贵公司目前主要用java还是kotlin？（都有，混合开发）  

​         贵公司对实习和正式岗的面试有没有什么不同的侧重点？（对于应届生要求都不是特别高，即便是正式岗在入职的时候也会先实习，然后有一个转正流程）  

   


###  二面： 

1. ​     StringBulider和StringBuffer的区别？    
2. ​     Fragment和Activity的异同，生命周期？    
3.  Activity的四种启动模式，singleTask的使用场景？ 
4.  安卓中有哪几种不同的Context，它们之间有什么区别和联系？ 
5.  用ApplicationContext是否可以启动一个Activity（可以，但启动后的Activity是一个新的栈） 
6.  安卓的动画种类，它们之间的区别？ 
7.  Java线程同步方式，哪种可以实现公平锁？ 
8.  安卓跨进程通信方式？Binder的作用？ 
9.  Tcp三次握手流程，seq的作用？是否听过滑动窗口？ 
10.  是否用过webView，JS和java怎么通信？ 
11.  是否用过flutter，flutter开发和原生开发的不同？ 

   反问：贵公司是否有混合开发和跨平台开发的技术栈？（有，目前主要用flutter）  

   


###  三面（hr）： 

1.  [项目]()经历，[项目]()中担任什么角色？ 
2.  [项目]()中有人和你有冲突怎么解决？ 
3.  在学校参加过哪些社团活动？ 
4.  最近一次感受最深的经历是什么？ 
5.  想在实习中获得怎样的收获？







---







作者：人类高质量男性
链接：https://www.nowcoder.com/discuss/714724?type=post&order=time&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack
来源：牛客网



为了避免敏感，题目不分公司统一写了，太简单的也不写了 

  [算法]()： 
  [两数之和]() 

  根据前序、中序恢复[二叉树]() 

  两个栈实现计算器 

  两个栈实现队列 

  [红黑树]()相关 

  树的最大高度 

  [最长回文子串]() 

  括号匹配 

  [二分查找]() 

  删除[链表]()倒数第k个结点 

  堆[排序]()变形 

  快排变形 

  遍历view group 

  两个结点的最近公共祖先 


  Java： 

  多线程相关 

  jvm 

 

  安卓： 

  自定义view 

  事件分发机制 


  网络： 
 http、https 

  tcp、udp 

 

  操作系统： 
 几乎没被问到 

  设计模式： 

  单例模式

#### 请你说一下touch事件在控件里面的传递过程

三个关键方法：

dispatchTouchEvent()、onInterceptTouchEvent()、onTouchEvent();

只有ViewGroup才能实现onInterceptTouchEvent()；而View则和Activity一样，也只实现了dispatchTouchEvent()、onTouchEvent()。

从结果来看，事件传递就是从activity传向ViewGroup，然后如果ViewGroup不拦截事件，则又把事件传给View，最后View来处理事件，如果View处理不了，则又把事件往上传给ViewGroup，然后ViewGroup如果也处理不了，则又把事件传给activity，最后由activity处理。

#### handler  activity退出时会怎么样（内存泄露）

#### handler使用时的一些注意事项

#### fragment和activity的生命周期

#### bundle底层原理

#### 反转链表（递归+迭代+继续改进）

#### 查找重复频率最高的数字（两种方法）

#### tCP/IP四次挥手，流量控制、拥塞控制

#### concurrenthashmap 1.71.8改进，为什么要用CAS

CAS+自旋锁+sychronized

自旋锁是利用CAS而设计的一种应用层面的锁。如下代码：

```java
// 0代表锁释放，1代表锁被某个线程拿走了
int lock = 0;

while(true){
      if(lock==0){
        int lock_ ;
        if(U.compareAndSwapInt(this,lock_,0,1)){
            ... // 获取锁后的逻辑处理

            // 最后释放锁
            lock = 0;
            break;
        }
    }  
}
```

自旋锁首先判断锁是否被其它线程拥有，若没有则尝试使用CAS获得锁；前两步失败都会重新循环再次尝试直到获得锁。最后逻辑处理完成要令lock=0来释放锁。冲突时间短的并发情景下这种方法可以大大提升效率。

1.7前concurrenthashmap采用的是锁分段策略来优化性能，相当于把整个数组拆分成多个小数组。每次操作只需要锁住操作的小数组即可，不同的segement之间互不影响，提高了性能。jdk1.8之后，对整个策略进行了重构：锁的不是segment，而是节点；

锁的粒度进一步被降低，并发的效率也提高了。

添加数据：首先使用CAS添加节点，如果添加失败，说明发生了并发冲突，再对节点进行上锁并插入数据。在并发较低的情景下无需加锁，可以显著提高性能。同时只会CAS尝试一次，也不会造成线程长时间等待浪费CPU时间的情况。

#### java集合

##### HashTble

线程安全的，但是实现方法是给每一个方法上锁。并发效率极低并且严重影响性能。

##### LinkedHashMap

遍历时从head出发可以按照插入顺序遍历所有节点。LinkedHashMap是基于LRU算法，每次读取数据都会把该节点提取到链表头。

##### TreeMap

底层是红黑树，所以拥有了Key排序的能力

#### Jvm垃圾回收

#### 说说java面向对象四大特性，多态的实现机制？表现在何处？

#### 访问权限修饰符 public、private、protected， 以及不写（默认）时的区别？

![](https://pic2.zhimg.com/v2-4c1052aba90dfdc2ddc31bedad0c01c5_b.jpg)

#### 介绍项目 介绍项目 介绍项目  介绍了三次







---

#### Java中为什么要用 clone？

在实际编程过程中，常常会遇到这种情况：有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能会需要一个和A完全相同新对象B，并且此后对B任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的。在java语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但clone()方法是其中最简单，也是最高效的手段。

对象的克隆，分为深克隆和浅克隆：

1. 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
2. 深克隆：创建一个新对象，属性中引用的其它对象也会被克隆，不再指向原有对象地址。

#### new一个对象的过程和clone一个对象的区别？

new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后

#### Java中实现多态的机制是什么？

java中声明父类去引用子类创建的对象，通过父类去调用子类的方法。这个过程是运行过程中动态绑定的。

#### 谈谈你对多态的理解？

多态就是指程序中定义的引用变量多指向的具体类型和通过该引用变量发出的方法调用在编程时不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源代码，就可以让引用变量绑定到各种不同的对象上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。**

java提供两种实现多态的机制：

编译时多态。编译时多态是通过方法重载实现的。

运行时多态。通过方法重写（子类覆盖父类方法）实现的

#### 谈谈你对面向对象的理解？

所谓对象就是由一组数据结构和处理它们的方法组成的，重点“数据”包括对象的特性、状态等的静态信息，“方法”也就是行为，包括该对象的对数据的操作、功能等能动信息。把相同行为的对象归纳为类，类是一个抽象的概念，对象是类的具体。

面向对象的目的：解决软件系统的可扩展性，可维护性和可重用性；

#### sychronized和violatile的原理和区别？

violatile保证数据的可见性。每当变量的值改变的时候，都会立马刷新到主内存中，所以其他线程想要读取这个数据，则需要从主内存中刷新到工作内存上。

而锁和同步关键字就是把更多个操作强制转化为原子化的过程。

##### violatile的作用：

- 保证可见性：变量修改对其它线程立刻可见
- 禁止指令重排

##### violatile的正确使用：

- boolean标志位

  共享变量只有被赋值和读取，没有其他的多个复合操作（比如先读数据再修改的复合运算 i++），我们就可以使用 volatile 代替 synchronized 或者代替原子类，因为赋值操作是原子性操作，而 volatile 同时保证了 可见性，所以是线程安全的。

- 双重检查（单例模式）

##### violatile的错误使用：

##### 如何才算线程安全？

1. 一个操作要符合原子性，要么不执行，要么一次性执行完成，在执行过程中不会受到其它操作的影响。
2. 对于变量的修改相对于其它线程必须立即可见
3. 代码的执行在其他线程看来要满足有序性

violatile不适合运用于需要保证原子性的场景，比如更新的时候需要依赖原来的值，最典型的就是a++的场景。

##### synchronized：

互斥同步。

#### 死锁

死锁发生的四个必要条件是： 1.资源互斥使用。 2.多个进程保持一定的资源，但又请求新的资源。 3.资源不可被剥夺。 4.多个进程循环等待。

 一般死锁的应对策略有： 1.死锁预防。如进程需要的所有资源，在一开始就全部申请好得到之后再开始执行。 2.死锁避免。如进程每次申请申请资源的时候，根据一定的算法，去看该请求可能不可能造成死锁，如果可能，就不给它分配该资源。 3.死锁处理。破坏四个必要条件的其中一个，比如kill掉一个进程。 4.死锁忽略。不管死锁，由用户自行处理，比如重启电脑。一般的系统其实都采取这种策略。

#### 请问类加载原理有了解吗，以及说说类的加载过程

一个Java文件从编码完成到最终执行，一般主要包括两个过程

- 编译
- 运行

编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。

运行，则是把编译生成的.class文件交给Java虚拟机(JVM)执行。

而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。

举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。

由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。

##### 类加载

类加载的过程主要分为三个部分：

- 加载
- 链接
- 初始化

##### 双亲委派机制

Jvm加载一个类的时候，类加载器会将其委派给其直接上级类加载器，上级类加载器重复该动作直至到Bootstrap Classloader，然后自上而下进行加载，直至完成类的加载。这样做的目的是防止程序重写破坏jdk 内部已经规定好的类

#### 进程和线程的区别？

进程是程序的一次执行过程，是程序在执行过程中的分配和管理资源的基本单位，每个进程都有自己的地址空间。

线程是CPU调度和分派的基本单位，它可以和同一进程下的其他线程共享全部资源。

联系：

线程是进程的一部分，一个进程可以有多个线程，但线程只能存在于一个进程中。

区别：

1. 根本区别：进程是操作系统资源调度的基本单位，线程是任务的调度执行的基本单位
2. 开销方面：进程都有自己的独立数据空间，程序之间的切换开销大；线程也有自己的运行栈和程序计数器，线程间的切换开销较小。
3. 共享空间：进程拥有各自独立的地址空间、资源，所以共享复杂，需要用IPC（Inter-Process Communication，进程间通信），但是同步简单。而线程共享所属进程的资源，因此共享简单，但是同步复杂，需要用加锁等措施。

操作系统中有两个重要概念：并发和隔离

并发：提高硬件利用率，进程的上下文切换比线程的上下文切换效率低，所以线程可以提高并发的效率

隔离：计算机的资源是共享的，当程序发生奔溃时，需要保证这些资源要被回收，进程的资源是独立的，奔溃时不会影响其他程 序的进行，线程资源是共享的，奔溃时整个进程也会奔溃

线程和并发有关系，进程和隔离有关系
