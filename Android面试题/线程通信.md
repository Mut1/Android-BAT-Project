#### 线程的创建

线程创建的常用方法

- 继承Thread重写run方法
- 实现Runnable重写run方法
- 实现Callable重写call方法

实现Callable重写call方法：

实现`Callable`和实现Runnable类似，但是功能更强大，具体表现在：

- 可以在任务结束后提供一个返回值，`Runnable`不行
- `call`方法可以抛出异常，`Runnable`的`run`方法不行
- 可以通过运行`Callable`得到的`Fulture`对象监听目标线程调用`call`方法的结果，得到返回值，（`fulture.get()`,调用后会阻塞，直到获取到返回值）

#### 线程中断

```java
public boolean isInterrupted() //判断中断标识位是否是true，不会改变标识位
public void interrupt()  //将中断标识位设置为true
public static boolean interrupted() //判断当前线程是否被中断，并且该方法调用结束的时候会清空中断标识位
```

需要注意的是`interrupt（）`方法并不会真的中断线程，它只是将中断标识位设置为`true`,具体是否要中断由程序来判断，如下，只要线程中断标识位为`false`,也就是没有中断就一直执行线程方法

```java
new Thread(new Runnable(){
      while(!Thread.currentThread().isInterrupted()){
              //执行线程方法
      }
}).start();
```

#### Thread为什么不能用stop方法停止线程

调用`Thread.stop()`方法是不安全的，这是因为当调用`Thread.stop()`方法时，会发生下面两件事：

1. 即刻抛出 `ThreadDeath`异常，在线程的`run()`方法内，任何一点都有可能抛出`ThreadDeath Error`，包括在`catch`或`finally`语句中。

2. 释放该线程所持有的所有的锁。调用`thread.stop()`后导致了该线程所持有的所有锁的突然释放，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。

#### 同步方法和同步代码块

###### 为何要使用同步？

`java`允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）， 将会导致数据不准确，相互之间产生冲突，因此加入**同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。**

###### 1. 同步方法

即有`synchronized`关键字修饰的方法, 由于`java`的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

```java
    public synchronized void save(){
   
    }
```

注：`synchronized`关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类

###### 2. 同步代码块

即有`synchronized`关键字修饰的语句块,被该关键字修饰的语句块会自动被加上内置锁，从而实现同步

```java
    synchronized(object){ 
    }
```

注：同步是一种高开销的操作，因此应该尽量减少同步的内容。
通常没有必要同步整个方法，使用`synchronized`代码块同步关键代码即可。

###### 3.使用特殊域变量（volatile）实现线程同步

- volatile关键字为域变量的访问提供了一种免锁机制，
- 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，
- 因此每次使用该域就要重新计算，而不是使用寄存器中的值
- volatile不会提供任何原子操作，它也不能用来修饰final类型的变量

#### 线程池ThreadPoolExecutor

线程池的工作原理：线程池可以减少创建和销毁线程的次数，从而减少系统资源的消耗，当一个任务提交到线程池时

- 首先判断核心线程池中的线程是否已经满了，如果没满，则创建一个核心线程执行任务，否则进入下一步
- 判断工作队列是否已满，没有满则加入工作队列，否则执行下一步
- 判断线程数是否达到了最大值，如果不是，则创建非核心线程执行任务，否则执行饱和策略，默认抛出异常

#### 线程池的种类

###### 1.FixedThreadPool

可重用固定线程数的线程池，只有核心线程，没有非核心线程，核心线程不会被回收，有任务时，有空闲的核心线程就用核心线程执行，没有则加入队列排队

###### 2.SingleThreadExecutor:

单线程线程池，只有一个核心线程，没有非核心线程，当任务到达时，如果没有运行线程，则创建一个线程执行，如果正在运行则加入队列等待，可以保证所有任务在一个线程中按照顺序执行，和`FixedThreadPool`的区别只有数量

###### 3.CachedThreadPool:

按需创建的线程池，没有核心线程，非核心线程有Integer.MAX_VALUE个，每次提交
任务如果有空闲线程则由空闲线程执行，没有空闲线程则创建新的线程执行，适用于大量的需要立即处理的并且耗时较短的任务

###### 4.ScheduledThreadPoolExecutor:

继承自`ThreadPoolExecutor`,用于延时执行任务或定期执行任务，核心线程数固定，线程总数为`Integer.MAX_VALUE`

#### 线程同步机制与原理

对象的`wait()`和`notify()/notifyall()`方法提供线程的同步功能。#### 结束线程



Thread.stop() 弃用

Thread.interrupt()

isInterrupted()       Thread.interrupted() 不仅会返回值，还是把中断值置为false

wait() notify()    notifyAll()

<img src="图片/线程通信.assets/image-20210717182726522.png" alt="image-20210717182726522" style="zoom:50%;" />

join()

<img src="图片/线程通信.assets/image-20210717183806619.png" alt="image-20210717183806619" style="zoom:50%;" />

yeild()

#### Sleep、yield、wait、join的区别

##### sleep与Wait的区别：

**sleep是线程方法，wait是object方法**

- sleep **，释放cpu资源，不释放锁资源，**如果线程进入sleep的话，释放cpu资源，如果外层包有Synchronize，那么此锁并没有释放掉。
- wait，**释放cpu资源，也释放锁资源，**一般用于锁机制中 肯定是要释放掉锁的，因为notify并不会立即调起此线程，因此cpu是不会为其分配时间片的，也就是说wait 线程进入等待池，cpu不分时间片给它，锁释放掉。

##### yield：

**让出CPU调度**，Thread类的方法，类似sleep，只是**不能由用户指定暂停多长时间 ，**并且yield()方法**只能让同优先级的线程**有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入**到可执行状态后**马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。

##### join：

一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。

##### 线程的状态

- 初始（NEW）
- 运行（RUNNABLE）reday+running
- 阻塞（BLOCKED）
- 等待（WAITING）
- 超时等待（TIMED_WAITING）
- 终止（TERMINATED）

