#### 优质文章

https://qwerhuan.gitee.io/2021/03/06/ji-suan-ji-wang-luo/https/

#### HHttp到底是什么

HyperText Transfer Protocol 超文本传输协议

- 超文本：在电脑中显示的、含有可以指向其他文本的链接的文本----HTML

#### 报文格式：Request

<img src="https://mut-pic-1305269047.cos.ap-nanjing.myqcloud.com/image-20210718131959397.png" style="zoom:50%;" />

#### 报文格式：Response

<img src="https://mut-pic-1305269047.cos.ap-nanjing.myqcloud.com/image-20210718132111160.png" style="zoom:50%;" />

#### 请求方法

- Get
  - 获取资源；没有Body
  - 幂等

- Post
  - 增加或修改资源；有Body
  - 不具有幂等性

- Put
  - 修改资源；有Body
  - 幂等

- DELETE
  - 删除资源；没有Body
  - 幂等
- HEAD

#### 状态码

- 1xx：临时性消息
- 2xx：成功
- 3xx：重定向
- 4xx：客户端错误
- 5xx：服务器错误

#### Header

作用：HTTP消息的元数据（metadata）

- Host：服务器主机地址
- Content-Type/ Content-length:Body的类型和长度
  - Content-length:内容的长度（字节）
  - Content-Type：内容的类型
    - text/html: html文本,用于浏览器页面响应
    - application/x-www-form-urlencoded:普通表单, encoded URL格式(纯文字表单)
    - multipart/form-data:多部分形式,一般用于传输包含二进制内容的多项内容
    - application/json:json形式,用于 Web Api的响应或POST/PUT请求
    - image/jpeg/  application/zlip..:单文件,用于 Web Api响应或POST/PUT请求
- Location:重定向的目标URL
- User-Agent:用户代理
- Cookie/Set-Cookie:发送 Cookie/设置 ookie
- Authorization:授权信息
- Accept:客户端能接受的数据类型。如text/ html
- Accept- Charset:客户端接受的字符集。如utf-8
- Accept- Encoding:客户端接受的压缩编码类型。如gzip
- Content- Encoding:压缩类型。如gzip

#### HTTPS

- HTTP Secure/HTTP over SSL/HTTP over TLS
- SSL: Secure Socket Layer-> TLS Transport Layer Security

##### 定义：

在HTTP之下增加的一个**安全层**，用于保障HTTP的加密传输

##### 本质：

在客户端和服务器之间用非对称加密协商出一套对称密钥，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输

##### 为什么不直接用非对称加密？

⾮对称加密由于使⽤了复杂了数学原理，因此计算相当复杂，如果完全使⽤⾮对称 加密来加密通信内容，会严重影响⽹络通信的性能

##### HTTPS连接的建立

- 示例
  - 客户端请求建立TLS连接
  - 服务器发回证书
  - 客户端验证服务器证书
  - 客户端信任服务器后，和服务器协商对称密钥
  - 使用对称密钥开始通信

- 实际

  1. Client Hello（客户端->服务器）
     - 可选的TLS版本
     - 可选的加密套件
       - 可选的对称加密算法
       - 可选的非对称加密算法
       - 可选的Hash算法
     - 客户端随机数
  2. Server Hello（服务器->客户端）
     - TLS版本
     - 加密套件：
       - 对称加密算法
       - 非对称加密算法
       - hash算法
     - 客户端随机数
     - 服务器随机数
  3. 服务器证书（服务器->客户端）
     - 服务器公钥（其实是个数据）(证书)
     - **服务器主机名**
     - 服务器地区
     - 服务器公钥的签名
     - 证书签发机构的公钥（用于验证这个[公钥签名]的另一个公钥）(证书签发机构的证书)
     - 证书签发机构的公钥的签名
     - 证书签发机构的签发机构的公钥(根证书机构的证书)
  4. Pre-master secret （客户端->服务器）
     - Master secret
     - 客户端加密密钥 
     - 服务端加密密钥 
     - 客户端 MAC secret 
     - 服务端 MAC secret
  5. 客户端：将使用加密通信
  6. 客户端发送：Finished
  7. 服务器通知：将使⽤加密通信
  8. 服务器发送：Finished

#### Http和Https

- http和https使用连接方式不同，默认端口也不一样，http是80，https是443。

#### WebSocket 与 Socket 的区别

1. Socket是传输控制层的接口。用户可以通过socket来操作底层TCP/IP协议族通信
2. Websocket是一个完整应用层协议
3. Socket更灵活，Websocket更易用
4. 两者都能做即时通讯

>
>
>当客户端收到的公钥是准确的时候，通信就是安全的。
>
>因为用正确公钥加密过的密文，只有服务端的私钥能解。
>
>那么如何保证，客户端收到正确的公钥呢?
>
>答案是：通过非对称加密来协商对称加密的密钥，服务端一旦把正确的公钥安全地送达到客户端后，后续的通信，为了保证高效通信，再采用对称加密来加密数据。
>
>具体的过程，后面会更加详细的阐述这一过程。



#### **摘要、签名、证书是啥?**

https://network.51cto.com/art/202010/628890.htm

- 客户端(浏览器)向服务端发出请求，服务端返回证书给客户端。
- 客户端拿到证书后，把证书里的签名与及明文信息分别取出来，然后会用自身携带的CA机构的公钥去解密签名，然后信息摘要1，然后再对明文信息进行HASH，得到一个信息摘要2，对比信息摘要1 和信息摘要2，如果一样，说明证书是合法的，也就是证书里的公钥是正确的。

以上采用的是非对称加密(CA的公钥和私钥)，保证了客户端接收到服务端正确的公钥，有了服务端的公钥后，后面的信息加密都可以使用这个公钥，而用这个公钥加密过后的密文，只有服务端的私钥能解，就算黑客拿到了也没法解开。





证书验证
客户端如何验证服务器的证书呢？首先得看看证书是怎么做出来的：



- 服务器向证书机构申请证书，同时提供自己的域名、地址、公钥等信息；
- 证书机构对服务器的信息使用hash算法得出一份128位的摘要，并对这份摘要使用自己的私钥进行非对称加密得到证书数字签名。
- 证书机构把服务器信息（明文）+数字签名+证书机构信息（包含证书机构公钥）发送给服务器
- 客户端请求服务器时，服务器把证书返回给客户端

客户端验证证书的重点就是：比较摘要 ：

- 客户端拿到证书，得到服务器信息、数字签名、证书机构信息
- 客户端对服务器信息进行hash算法计算得出一份摘要S1
- 客户端使用证书机构的公钥对数字签名进行解密得到一份摘要S2
- 对比S1和S2即可辨别此证书是否来自服务器且没经过篡改

#### 证书链

客户端验证证书的流程很简单：使用证书机构公钥解开证书的数字签名后进行比对即可。但这里有一个问题：如何保证证书机构的公钥可信 ？假如黑客使用自己的私钥加密，同时把证书机构的公钥修改成自己的公钥，那岂不是非常危险？

互联网中的主机对象非常多，但证书机构却不多。计算机产商，会在系统中安装一些根证书机构的信息，其中就包含了这些机构的公钥。这些公钥是在一定程度上是绝对安全的，是可以信任的。客户端可以使用这些公钥对数字签名进行解密。安全问题，终于得到了完美的解决。

系统中预装的证书机构是有限的，但世界上每时每刻申请数字证书却非常多，他们“忙不过来”，因此有了二级证书机构。二级证书机构由根证书机构签发，二级证书机构再去给服务器签发证书。那么此时如何进行证书验证呢？还是一样的道理：

利用根证书机构给二级证书机构签发的时候同样是一份数字证书，其中包含了二级证书机构信息、数字签名、根证书机构信息
服务器的数字证书中包含了二级证书机构的数字证书
客户端使用根证书机构的公钥对二级证书机构的数字签名进行解密得到摘要再进行比对，得到二级证书机构的公钥
使用二级证书机构的公钥对服务器证书进行验证
同理，三级、四级证书机构验证都类同。在浏览器中，我们可以查看网站的证书链：


