### [143\. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

Difficulty: **中等**


给定一个单链表 `L`的头节点 `head` ，单链表 `L` 表示为：

` L<sub style="display: inline;">0 </sub>→ L<sub style="display: inline;">1 </sub>→ … → L<sub style="display: inline;">n-1 </sub>→ L<sub style="display: inline;">n </sub>`  
请将其重新排列后变为：

`L<sub style="display: inline;">0 </sub>→ L<sub style="display: inline;">n </sub>→ L<sub style="display: inline;">1 </sub>→ L<sub style="display: inline;">n-1 </sub>→ L<sub style="display: inline;">2 </sub>→ L<sub style="display: inline;">n-2 </sub>→ …`

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例 1:**

![](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png)

```
输入: head = [1,2,3,4]
输出: [1,4,2,3]
```

**示例 2:**

![](https://pic.leetcode-cn.com/1626420320-YUiulT-image.png)

```
输入: head = [1,2,3,4,5]
输出: [1,5,2,4,3]
```

**提示：**

*   链表的长度范围为 `[1, 5 * 10<sup>4</sup>]`
*   `1 <= node.val <= 1000`

#### Solution

1. 找到链表中点，如果是偶数个返回左边的中点

2. 分割链表；
3. 从中点翻转链表
4. 合并链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public void reorderList(ListNode head) {
        if(head.next==null) return;
        ListNode head1=head;
        ListNode mid=null;
        mid=findMid(head);
        ListNode head2=reverseList(mid.next);
        mid.next=null;
        mergeLists(head1,head2);
    }

    ListNode findMid(ListNode node){    
            ListNode slow= node;
            ListNode fast=node;
            while(fast.next!=null&&fast.next.next!=null){
                slow=slow.next;
                fast=fast.next.next;
            }
            return slow;
    }

    ListNode reverseList(ListNode head){
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }

    ListNode mergeLists(ListNode head1,ListNode head2){
        ListNode newHead=head1;
            ListNode next1=head1;
            ListNode next2=head2;
            while(head1!=null&&head2!=null){
                next1=head1.next;
                head1.next=head2;
                head1=next1;
                next2=head2.next;
                head2.next=head1;
                head2=next2;
            }
            return newHead;
    }
}
```