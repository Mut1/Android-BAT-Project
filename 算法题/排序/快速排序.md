## 快速排序

#### 执行流程

1. 从序列中选择一个轴点元素（pivot）
   - 假设每次选择0位置的元素为轴点元素
2. 利用pivot将序列分割成两个序列
   - 将小于pivot的元素放在pivot前面（左侧）
   - 将大于pivot的元素放在pivot后面（右侧）
   - 等于pivot的元素放哪边都可以
3. 对子序列进行1.2.操作
   - 直到不能再分隔（子序列中只剩下1个元素）

#### 快速排序的本质

逐渐将每一个元素都转换成轴点元素

最好、平均时间复杂度O（nlogn）

最坏时间复杂度O（n^2）

属于不稳定排序

```java
void quickSort(Integer[] arr){
     sort(arr,0,arr.length);
}
/**
	 * 对 [begin, end) 范围的元素进行快速排序
	 * @param begin
	 * @param end
	 */
private void sort(Integer[] arr,int begin,int end){
  	if(end-begin<2) return;
	  // 确定轴点位置 O(n)
  	int mid=pivotIndex(begin,end);
  	// 对子序列进行快速排序
  	sort(arr,begin,mid);
  	sort(arr,mid+1,end);
}
/**
	 * 构造出 [begin, end) 范围的轴点元素
	 * @return 轴点元素的最终位置
	 */
private int pivotIndex(Integer[] arr,int begin,int end){
  	// 备份begin位置的元素
  	int pivot=arr[begin];
  	// end指向最后一个元素
  	end--;
  	while(begin<end){
      while(begin<end){
        if(arr[end]>pivot){// 右边元素 > 轴点元素
          end--
        }else{ // 右边元素 <= 轴点元素
          arr[begin]=arr[end];
          begin++;
          break;
        }
      }
      
     	while(begin<end){
        if(arr[begin]<pivot){ // 左边元素 < 轴点元素
          begin++;
        }else{ // 左边元素 >= 轴点元素
          arr[end]=arr[begin];
          end--;
          break;
        }
      }	
    }
  	// 将轴点元素放入最终的位置
  	arr[begin]=pivot;
	  // 返回轴点元素的位置
  	return begin;
}
```

#### 优化方法1

随机选择轴点(为了对序列进行均匀分隔，放置出现最坏时间复杂度O(n^2))

```java
swap(arr,begin,begin+Math.random()*(end-begin));
```

