## 插入排序

#### 执行流程

1. 在执行过程中，插入排序会将序列分为2部分
   - 头部是已经排好序的，尾部是待排序的
2. 从头开始扫描每一个元素
   - 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序

- 最坏、平均时间复杂度O（n^2）
- 最好时间复杂度O(n)
- 空间复杂度O（1）
- 稳定排序
- 当逆序对的数量极少时，插入排序的效率特别高
  - 真正速度比O（nlogn）的快速排序还快
- 数据量不是特别大的时候，插入排序效率也特别好

```java
void InsertionSort1(Integer[] arr){
  for(int begin=1;i<arr.length;begin++){
    int cur=begin;
    while(cur>0&&arr[cur-1]>arr[cur]){
      swap(arr,cur,cur-1);
      cur--;
    }
  }
}
```

#### 优化一

- 将插入转化为挪动
  - 先将待插入的元素备份
  - 头部有序数据中比待插入元素大的，都朝尾部方向挪动一个位置
  - 将待插入元素放到最终的合适位置

```java
void InsertionSort2(Integer[] arr){
  for(int bgein=1;begin<arr.length;begin++){
    int cur= begin;
    Integer v=arr[cur];
    while(cur>0&&v<arr[cur-1]){
      arr[cur]=arr[cur-1];
      cur--;
    }
    arr[cur]=v;
  }
}
```

#### 优化三：利用二分搜索进行优化（优化了比较次数）

```java
void InsertionSort3(Integer[] arr){
  for(int bgein=1;begin<arr.length;begin++){
   		int insertion = search(arr,begin);
    	int cur=arr[begin];
    	for(int i= begin;i>insertion;i--){
        arr[i]=arr[i-1];
      }
    	arr[insertion]=cur;
  }
}
/**
	 * 利用二分搜索找到 index 位置元素的待插入位置
	 * 已经排好序数组的区间范围是 [0, index)
	 * @param index
	 * @return
	 */
private int search(Integer[] arr,int index){
  	int v=arr[index];
  	int begin=0;
    int end=index;
    while(begin<end){
  	  int mid=(begin+end)>>1;
  	  if(v<arr[mid]){
    	  end=mid;
  	  }else{
  	    begin=mid+1;
  	  }
 	 }
	  return begin;
}
```

